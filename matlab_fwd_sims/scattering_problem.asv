%% Define constants
light_speed = 299792458;
frequency = 5e9;
k = 2 * pi * frequency / light_speed;
wavelength = light_speed / frequency;
mesh_size = wavelength / 5; % Use a slightly finer mesh

%% Create a geometry
model = createpde;

% Create outer square
outerSquare = [3 4 0 1 1 0 0 0 1 1]';

% --- Wavy bottom edge for the hole (same as your definition) ---
width  = 0.4;
height = 0.2;
xCenter = 0.5;
yCenter = 0.5;
xLeft   = xCenter - width/2;
xRight  = xCenter + width/2;
yBottom = yCenter - height/2;
yTop    = yCenter + height/2;
NwavePts = 100;
amp  = 0.01;
freq = 1;
xWave = linspace(xLeft, xRight, NwavePts);
yWave = yBottom + amp * sin(freq * 2*pi * (xWave - xLeft)/width);
xHole = [xWave, xRight, xLeft];
yHole = [yWave, yTop, yTop];
innerPoly = [2, numel(xHole), xHole, yHole]';

% --- Combine and make geometry ---
maxRows = max(size(outerSquare,1), size(innerPoly,1));
outerSquare(end+1:maxRows,1) = 0;
innerPoly(end+1:maxRows,1)   = 0;
gd = [outerSquare, innerPoly];
ns = char('SQ1','RC1')';
sf = 'SQ1 - RC1';
[g, bt] = decsg(gd, sf, ns);
geometryFromEdges(model, g);

%% Apply boundary condition and define the PDE for the SCATTERED field u_scat

% --- Outer Boundary: Absorbing Boundary Condition (Robin) ---
% We need q + ik*u = 0. In MATLAB's format, this is q = -ik, g = u.
applyBoundaryCondition(model, "neumann", ...
                       Edge=(1:4), ...
                       q = -1i*k, ...
                       g = 0);

% --- Inner Boundary (Obstacle): Total field is zero ---
% u_total = u_inc + u_scat = 0  =>  u_scat = -u_inc
incident_field = @(location,state) -exp(1i*k*location.y);
applyBoundaryCondition(model, "dirichlet", ...
                       Edge=(5:106), ...
                       u = incident_field);

% --- Define PDE coefficients ---
c = 1;
a = -k^2;
f = 0;
specifyCoefficients(model, m=0, d=0, c=c, a=a, f=f);

%% Mesh the geometry
generateMesh(model, Hmax=mesh_size);
figure
pdemesh(model);
axis equal
title('Problem Geometry and Mesh');

%% Solve for the scattered field u_scat
result = solvepde(model);
u_scat = result.NodalSolution;

%% Plot the results
nodes = model.Mesh.Nodes;
x = nodes(1, :);
y = nodes(2, :);

% Incident field at all node locations
u_inc_nodes = exp(1i * k * y);

% Total field is the sum of incident and scattered fields
u_total = u_scat + u_inc_nodes.';

figure;
pdeplot(model, 'XYData', abs(u_total), 'Mesh', 'off');
colormap("hot"); % Use 'hot' to match Python plot
colorbar;
xlabel('x');
ylabel('y');
title('Magnitude of Total Field |u_{inc} + u_{scat}|');
axis equal;

%% Record measurements on the OBSTACLE's bottom edge

% Original measurement points (edges)
x_edges = linspace(0, 1, 100);  % 100 points, defining 99 intervals
y_edges = linspace(0, 1, 100);
% Midpoints where you want to save data
dx = x_edges(2) - x_edges(1);
x_meas_mid = x_edges(1:end-1) + dx/2;  % 99 midpoints

% y coordinate along bottom edge (assuming y=0)
y_meas = zeros(size(x_edges));

y_meas_mid = zeros(size(x_meas_mid));
u_inc_meas = exp(1i * k * y_meas_mid);

% Interpolate u at left and right edges of each interval
u_left = interpolateSolution(result, x_edges(1:end-1), y_meas(1:end-1)) + u_inc_meas;
u_right = interpolateSolution(result, x_edges(2:end), y_meas(2:end)) + u_inc_meas;

% Interpolate u at left and right edges of each interval
u_inc_edges = exp
u_total_eges = interpolateSolution(result, x_edges, y_edges) + u_inc_edges;
% Average value for each interval midpoint
u_avg = (u_left + u_right) / 2;

% Now save measurement table with midpoints and averaged values
T = table(x_meas_mid.', zeros(length(x_meas_mid),1), abs(u_avg(1,:)), ...
          'VariableNames', {'x', 'y', 'u'});

writetable(T, 'measurements_avg.csv');